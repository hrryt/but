% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/but.R
\name{but}
\alias{but}
\title{Modify a Function's Formals or Output}
\usage{
but(.f, ..., .first = FALSE, .wrap = TRUE, .pass_all = TRUE)
}
\arguments{
\item{.f}{a function (a primitive or a closure, i.e., “non-primitive”)}

\item{...}{modified formals}

\item{.first}{should supplied formals come first, and in the order specified?}

\item{.wrap}{should \code{.f} be wrapped in a new function or its formals modified directly?}

\item{.pass_all}{should arguments not present in the formals of \code{.f} be passed to \code{.f}
if it has \link{dots} to absorb them?}
}
\value{
A function.
}
\description{
Constructs a function that calls the input function with modified formal arguments
and/or additional processing of its output.
}
\details{
Each named argument supplied to \code{but()} replaces the formal argument of \code{.f}
with that name. Otherwise it is added to the end of the argument list and,
if \code{.pass_all}, passed to \code{.f }.

If \code{.f} is a primitive without a well-defined argument list, a warning is given,
its formals are assumed to be \code{alist(... = )}, and \code{.first} is set to \code{TRUE}.

If an argument supplied to \code{but()} 'references' \code{.out} (see examples),
it is treated as a language object and appended to the body of the returned function
after the call to \code{.f} is assigned to \code{.out}, such that the output of \code{.f}
can be modified before it is returned.
}
\examples{
# supply default arguments to read.table
read.csv |> but(stringsAsFactors = TRUE, strip.white = TRUE)

`+` #primitive
double <- `+` |> but(e2 = e1)
double(4)

start_repeats <- grepl |> but( #create new argument n
  x = , n = 2, pattern = sprintf("^\%s{\%i}", substr(x, 1, 1), n),
  .first = TRUE
)
start_repeats("hhi", 3)
start_repeats("Hhello", ignore.case = TRUE)

# an argument that references .out
(slapply <- lapply |> but(.out |> simplify2array()))
3:9 |> slapply(seq) |> slapply(fivenum, na.rm = FALSE)
cor_dist <- cor |> but({
  dd <- as.dist((1 - .out)/2)
  plot(hclust(dd))
  dd
})
cor_dist(USJudgeRatings, method = "spearman") |> round(2)

but(lm) # lm(weights = weights) will error if run
# use .wrap = FALSE to avoid the pitfalls of
# non-standard evaluation in the body of .f
lm_for_pipe <- lm |> but(data = , .first = TRUE, .wrap = FALSE)
mtcars |> subset(cyl == 4) |> lm_for_pipe(mpg ~ disp)

# use .pass_all = FALSE to avoid passing
# extra arguments to the dots of .f
outer |> but(
  n = , X = seq_len(n), Y = X,
  .first = TRUE, .pass_all = FALSE
) |> print() |> do(4) |> print()

(numbers <- seq(1, 3, 0.5))
but(split, f = floor(x))(numbers) #equivalent to using pipe

#dangerous; see warning
`last<-` <- but(`[[<-`, x = , i = length(x), value = )
last(numbers) <- 0
numbers

}
\seealso{
\code{\link{|>}}, \code{\link[=do]{do()}}.
}
